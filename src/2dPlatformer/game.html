<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <style>
    html, body {
      overflow: hidden;
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
    }

    #renderCanvas {
      width: 100%;
      height: 100%;
    }
  </style>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="moveSet.js"></script>
  <script src="enemyMovement.js"></script>
  <script src="createEnemy.js"></script>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<script>
  window.addEventListener("DOMContentLoaded", function (){
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    let inputMap = {};
    window.addEventListener("keydown", (e) => { inputMap[e.key] = true; });
    window.addEventListener("keyup", (e) => { inputMap[e.key] = false; });

    let chara, scene, camera, background;
    let boxMat, playerSprite;
    // 1. Parse level number from URL
    const urlParams = new URLSearchParams(window.location.search);
    const level = urlParams.get("level") || "1";

    // 2. Define JSON loader
    async function loadLevel(levelNumber) {
      const response = await fetch(`levels/level${levelNumber}.json`);
      return await response.json();
    }

    const createScene = function (){
      scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3.White();

      camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 0, -10), scene);
      camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
      camera.setTarget(BABYLON.Vector3.Zero());
      // Define orthographic size (basically "zoom level")
      let ratio = engine.getRenderWidth() / engine.getRenderHeight();
      let orthoSize = 6; // Adjust this number for zoom

      camera.orthoLeft   = -orthoSize * ratio;
      camera.orthoRight  =  orthoSize * ratio;
      camera.orthoTop    =  orthoSize;
      camera.orthoBottom = -orthoSize +1;
      const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
      // Add a static background image (wallpaper style)
      background = new BABYLON.Layer("back", "resources/forest.png", scene, true);

      // Smaller player box
      chara = BABYLON.MeshBuilder.CreateBox("boxy", {width:0.8, height:1, depth:0.5}, scene);
      //player sprite
      const spriteManagerPlayer = new BABYLON.SpriteManager("playerManager", "resources/character.png", 1,
              { width: 225, height: 150 }, scene, BABYLON.Texture.NEAREST_SAMPLINGMODE);
      playerSprite = new BABYLON.Sprite("pp", spriteManagerPlayer);
      playerSprite.size = 1;
      // playerSprite.position = new BABYLON.Vector3(0, 0, 0);
      playerSprite.cellIndex = 0;
      //playerSprite.playAnimation(6, 9, true, 200);

      // Create a material for the box
      boxMat = new BABYLON.StandardMaterial("boxMat", scene);

      // Set the texture (replace "character.png" with your file path or URL)
      boxMat.diffuseTexture = new BABYLON.Texture("resources/chara.png", scene);
      boxMat.diffuseTexture.hasAlpha = true;
      chara.material = boxMat;
      chara.position.x = 1;
      chara.isVisible = false;
      playerSprite.position = chara.position;
      //chara.position.y = -5;
      return scene;
    };

    function createTileGrid(scene, levelMap) {
      // const levelMap = [
      //     [3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1],
      //     [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1],
      //     [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,3,0,0,0,0,0,0,0,0,0,6,0,0,0,6,0,0,1,1,1,1,1],
      //     [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,1,1,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,1,1,1,1,1],
      //     [1,3,3,3,3,3,3,4,0,0,0,5,3,0,0,0,0,0,0,2,0,0,0,0,5,1,1,1,1,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1],
      //     [1,1,1,1,1,1,1,1,3,3,3,1,1,0,0,0,0,5,3,4,0,5,3,3,1,1,1,1,1,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,1,1,1,1,1],
      //     [1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,5,1,1,1,3,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1],
      //     [1,1,1,1,1,1,1,1,1,1,1,1,1,7,7,7,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1],
      //     [1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,1],
      //     [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      //     [1,1,1,1,1,1,0,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      //     [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,1],
      //     [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1,1,1,1,1],
      //     [1,1,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,3,0,0,0,0,0,0,3,3,7,7,7,3,3,7,7,7,3,3,7,7,3,3,3,1,1,1,1,1,1],
      //     [1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,2,0,2,0,0,1,0,0,2,0,0,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      //     [1,1,0,0,0,0,0,0,3,3,3,3,1,3,3,3,3,3,3,3,1,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      //     [1,1,4,0,0,0,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      //     [1,1,1,4,0,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      //     [1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      //     [1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      //     [1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      //     [1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      //     [1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1],
      //     [1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
      //     [1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
      //     [1,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,2,0,0,0,5,1,3,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,1,1],
      //     [1,1,0,0,3,0,0,0,0,0,0,0,5,1,3,3,3,3,3,3,1,1,1,3,3,3,3,3,3,3,0,0,0,0,0,3,3,3,3,3,0,0,0,0,2,0,0,0,1,1],
      //     [1,1,3,3,1,4,0,0,2,0,0,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,7,7,7,7,3,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1],
      //     [1,1,1,1,1,1,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,2,0,1,1,1,1,1,1,1],
      //     [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1],
      //     [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1],
      //     [1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,1,1],
      //     [1,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,3,4,0,0,0,1,1,0,0,1],
      //     [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1],
      //     [1,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1],
      //     [1,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
      //     [1,1,1,1,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      //     [1,1,1,1,0,0,0,0,6,0,0,0,6,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      //     [1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      //     [1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      //     [1,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,0,0,6,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1],
      //     [1,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
      //     [1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
      //     [1,3,3,3,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      //     [1,1,1,1,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      //     [1,1,1,1,3,0,0,0,0,0,0,0,6,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      //     [1,1,1,1,1,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      //     [1,1,1,1,1,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,0,0,0,0,0,0,0,0,0,0,1,1,3,1,1,1,1],
      //     [1,1,1,1,1,1,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,1,1,1,1,1,1,1,1],
      //     [1,1,1,1,1,1,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1],
      //     [1,1,1,1,1,1,7,7,7,7,2,0,2,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1],
      //     [1,1,1,1,1,1,1,1,1,1,7,1,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1],
      //     [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
      // ];
      const tiles = [];
      const tileSize = 1;
      const rows = levelMap.length;

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < levelMap[row].length; col++) {
          const cell = levelMap[row][col];
          if (cell !== 0) {
            //const tile = BABYLON.MeshBuilder.CreatePlane("tile", { size: tileSize }, scene);
            const tile = BABYLON.MeshBuilder.CreateBox("tile", { width: tileSize, height: tileSize, depth: 0.2 }, scene);
            tile.checkCollisions = true;
            //Position tile in grid
            // X → column, Y → row (but invert row so bottom = 0)
            const rows = levelMap.length;
            const yOffset = -(rows - 1) * tileSize; // shift grid down so bottom row = 0

            // Different materials based on cell type
            const mat = new BABYLON.StandardMaterial("tileMat", scene);
            if (cell === 1) {
              mat.diffuseTexture = new BABYLON.Texture("resources/tiles/Tile_12.png", scene);
              mat.diffuseTexture.hasAlpha = true;
              tile.tileType = 1;
            } else if (cell === 2) {
              const enemy = createEnemy(scene, col * tileSize, yOffset + (rows - 1 - row) * tileSize, 2,);
              window.enemies.push(enemy);
              continue;
            }else if (cell === 3) {
              mat.diffuseTexture = new BABYLON.Texture("resources/tiles/Tile_02.png", scene);
              mat.diffuseTexture.hasAlpha = true;
              tile.tileType = 3;
            }else if (cell === 4) {
              mat.diffuseTexture = new BABYLON.Texture("resources/tiles/Tile_03.png", scene);
              mat.diffuseTexture.hasAlpha = true;
              tile.tileType = 4;
            }else if (cell === 5) {
              mat.diffuseTexture = new BABYLON.Texture("resources/tiles/Tile_01.png", scene);
              mat.diffuseTexture.hasAlpha = true;
              tile.tileType = 5;
            }else if (cell === 6) {
              mat.diffuseTexture = new BABYLON.Texture("resources/tiles/Tile_08.png", scene);
              mat.diffuseTexture.hasAlpha = true;
              tile.tileType = 6;
            }else if (cell === 7) {
              mat.diffuseTexture = new BABYLON.Texture("resources/tiles/Tile_30.png", scene);
              mat.diffuseTexture.hasAlpha = true;
              tile.tileType = 7;
            }else if (cell === 8) {
              const endSpriteMenager = new BABYLON.SpriteManager("endManager", "resources/craftpix-net-672461-free-swamp-game-tileset-pixel-art/4 Animated objects/Flag.png", 1,
                      { width: 48, height: 48 }, scene, BABYLON.Texture.NEAREST_SAMPLINGMODE);
              let endSprite = new BABYLON.Sprite("end", endSpriteMenager);
              endSprite.size = 1;
              endSprite.cellIndex = 0;
              endSprite.playAnimation(0, 3, true, 160);
              endSprite.position = new BABYLON.Vector3(col * tileSize, yOffset + (rows - 1 - row) * tileSize, 0);
              tile.tileType = 8;
              tile.isVisible = false;
            }

            tile.material = mat;
            tile.position.x = col * tileSize;
            tile.position.y = yOffset + (rows - 1 - row) * tileSize;
            tile.position.z = 0;
            tiles.push(tile);
          }
        }
      }
      return tiles;
    }

    let gameScene = createScene(engine);

    window.enemies = [];
    let tiles;
    loadLevel(level).then(levelMap => {
      tiles = createTileGrid(scene, levelMap);
      // Health UI
      window.guiTex = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
      window.heartsPanel = new BABYLON.GUI.StackPanel();
      window.heartsPanel.isVertical = false;
      window.heartsPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
      window.heartsPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
      window.heartsPanel.left = "0px";
      window.heartsPanel.top = "0px";
      window.heartsPanel.paddingTop = "-450px";
      guiTex.addControl(window.heartsPanel);

      if (typeof buildHearts === "function") {

        buildHearts(6);
      }

      setupPlayer(chara, tiles, scene, playerSprite);

      engine.runRenderLoop(function () {
        chara.showBoundingBox = true;
        updateMovement(inputMap,chara, scene ,playerSprite, tiles);

        const verticalOffset = 2;
        const horizontalOffset = 2;
        camera.position.x += ((chara.position.x + horizontalOffset) - camera.position.x) * 0.1;
        camera.position.y += ((chara.position.y + verticalOffset) - camera.position.y) * 0.1;

        for (let enemy of window.enemies) {
          enemyMovement(enemy);
        }
        gameScene.render();
      });
      window.addEventListener("resize", function () {
        engine.resize();
      });
    });



  });

</script>
</body>
</html>